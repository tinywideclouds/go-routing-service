# ðŸ“‹ Service Requirements: Routing Service

**Service:** `go-routing-service`
**Domain:** Secure Messaging / Delivery
**Status:** Live / Refactored

---

## L1: Business & High-Level Requirements
*High-level goals defining the service's value proposition.*

* **R1.1 Secure Routing:** The service must route encrypted messages between users without ever having access to the message content or keys ("Sealed Sender").
* **R1.2 Reliable Delivery:** Messages must eventually reach the recipient, regardless of whether they are currently online or offline.
* **R1.3 Real-Time Responsiveness:** Online users should receive messages with minimal latency (<200ms target for hot path).
* **R1.4 Scalability:** The architecture must support horizontal scaling of ingestion and delivery nodes independently.

---

## L2: Functional & System Requirements
*Specific capabilities the system must provide.*

### Ingestion & Processing
* **R2.1 Unified Ingestion:** All messages (REST API or internal events) must enter through a common pipeline that enforces validation and prioritization.
* **R2.2 Prioritization:** The system must distinguish between "Standard" messages (Chat) and "High Priority" signals (Device Sync, Revocation).
* **R2.3 Smart Routing:**
    * **Online Users:** Route to **Hot Queue** (Low Latency).
    * **Offline Users:** Route directly to **Cold Queue** (Durable Storage).

### Storage & Queues
* **R2.4 Tiered Storage:**
    * **Hot Queue:** In-memory/Ephemeral store (e.g., Redis) for active sessions.
    * **Cold Queue:** Durable disk-based store (e.g., Firestore) for offline history.
* **R2.5 Automatic Migration:** When a user disconnects (last session ends), all pending messages in the Hot Queue must be automatically migrated to the Cold Queue.

### Delivery & Notification
* **R2.6 "Poke-then-Pull" Model:** The service shall not push payloads via WebSocket. It sends a lightweight "Poke" signal; the client must request the data.
* **R2.7 Fan-Out:** A "Poke" for a user must be broadcast to *all* active connections for that user across all service instances.
* **R2.8 Push Fallback:** If a user is offline, the service must trigger a push notification command to the downstream Notification Service.

---

## L3: Technical & Implementation Constraints
*Detailed rules for implementation, data integrity, and protocol compliance.*

### ID Stability & Idempotency (CRITICAL)
* **R3.1 Single Source of Truth ID:** The `RoutingProcessor` must generate a definitive, unique `MessageID` (UUID) upon ingestion.
* **R3.2 ID Immutability:** This `MessageID` must be preserved strictly across all state transitions (Hot Enqueue -> Pending -> Cold Migration -> Client Delivery). It must never be regenerated by storage adapters.
* **R3.3 Idempotent Writes:** Storage adapters must support idempotent writes using the `MessageID` as the primary key/document ID. Re-enqueuing the same message must not create a duplicate record.

### Message Lifecycle
* **R3.4 Ephemeral Drop:** Messages flagged as `IsEphemeral: true` (e.g., Typing Indicators) must be dropped if the Hot Queue fails or during Hot-to-Cold migration. They must never be written to Cold Storage.
* **R3.5 Atomic Acknowledgement:** The `Acknowledge` API must support batch deletion. Acknowledgement is the *only* signal that confirms delivery and triggers data removal.

### Protocol & Security
* **R3.6 ProtoJSON Compliance:** All JSON payloads for `SecureEnvelope` must strictly adhere to the Protobuf JSON mapping rules (e.g., `bytes` fields encoded as Base64 strings).
* **R3.7 Auth Validation:** All WebSocket and HTTP endpoints must validate JWTs via a JWKS provider.
* **R3.8 Context Context:** User Identity (URN) must be derived strictly from the validated Auth Token, never from the request body.